<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Safe</title>
  <!-- External CSS - using absolute path with file:// protocol -->
  <link rel="stylesheet" href="file:///Users/dhrupadsah/personal/projects/team-safe/frontend/src/renderer/css/styles.css">
  <!-- Fallback inline styles - only basic essential styling -->
  <style>
    /* Basic fallback styles in case the external CSS doesn't load */
    body { background-color: #f5f5f7; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    .container { display: flex; flex-direction: column; height: 100vh; }
    .header { background-color: #0071E3; color: white; padding: 12px 16px; display: flex; align-items: center; }
    .main-content { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 20px; }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-logo">TS</div>
      <h1>Team Safe</h1>
    </header>
    
    <main class="main-content">
      <!-- Auth View -->
      <div class="card" id="auth-view">
        <div class="logo-container">
          <div class="logo-placeholder">TS</div>
        </div>
        <h2>Welcome to Team Safe</h2>
        <p>Secure secret sharing for your team. Login or create an account to get started.</p>
        
        <div id="error-container" class="error-message" style="display: none;"></div>
        <div id="success-container" class="success-message" style="display: none;"></div>
        <div id="loading-container" class="loading" style="display: none;">Processing...</div>
        
        <div class="tabs">
          <div class="tab active" data-tab="login">Login</div>
          <div class="tab" data-tab="register">Register</div>
        </div>
        
        <div class="tab-content active" id="login-tab">
          <div class="form-group">
            <label for="email">Company Email</label>
            <input type="email" id="email" placeholder="name@company.com">
          </div>
          <div class="form-group">
            <label for="password">Password</label>
            <input type="password" id="password" placeholder="••••••••">
          </div>
          <button class="btn btn-primary" id="login-btn">Login</button>
          <button class="btn btn-secondary" id="forgot-password-btn">Forgot Password?</button>
        </div>
        
        <div class="tab-content" id="register-tab">
          <div class="form-group">
            <label for="register-email">Company Email</label>
            <input type="email" id="register-email" placeholder="name@company.com">
          </div>
          <div class="form-group">
            <label for="first-name">First Name</label>
            <input type="text" id="first-name" placeholder="John">
          </div>
          <div class="form-group">
            <label for="last-name">Last Name</label>
            <input type="text" id="last-name" placeholder="Doe">
          </div>
          <div class="form-group">
            <label for="register-password">Password</label>
            <input type="password" id="register-password" placeholder="••••••••">
          </div>
          <div class="form-group">
            <label for="confirm-password">Confirm Password</label>
            <input type="password" id="confirm-password" placeholder="••••••••">
          </div>
          <button class="btn btn-primary" id="register-btn">Create Account</button>
        </div>
      </div>
      
      <!-- Dashboard View (hidden initially) -->
      <div class="dashboard-view" id="dashboard-view">
        <!-- Will be populated by JS -->
      </div>
      
      <!-- Notification toast -->
      <div class="notification-toast" id="notification-toast">
        <div class="notification-content">
          <div class="notification-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
              <polyline points="22 4 12 14.01 9 11.01"></polyline>
            </svg>
          </div>
          <div class="notification-message" id="notification-message">New secret received!</div>
        </div>
        <button class="notification-close" id="notification-close">×</button>
      </div>
    </main>
    
    <!-- Secret Sharing Modal (hidden initially) -->
    <div class="modal-overlay" id="share-modal">
      <div class="modal">
        <h3 class="modal-title">Share Secret</h3>
        <div class="form-group">
          <label for="secret-text">Secret Text</label>
          <input type="text" id="secret-text" placeholder="Enter your secret message">
        </div>
        <div class="modal-buttons">
          <button class="btn" id="cancel-share-btn">Cancel</button>
          <button class="btn btn-primary" id="confirm-share-btn">Share</button>
        </div>
      </div>
    </div>
    
    <footer class="footer">
      Team Safe • Secure Secret Sharing
    </footer>
  </div>

  <!-- Import Services -->
  <script src="../services/api.js" type="module"></script>
  <script src="../services/crypto.js" type="module"></script>
  
  <!-- Main App Script -->
  <script type="module">
    import { AuthService, UserService, SecretService } from '../services/api.js';
    import { generateKeyPair, encryptWithPublicKey, decryptWithPrivateKey, storePrivateKey, retrievePrivateKey } from '../services/crypto.js';
    
    // DOM Elements
    const authView = document.getElementById('auth-view');
    const dashboardView = document.getElementById('dashboard-view');
    const errorContainer = document.getElementById('error-container');
    const successContainer = document.getElementById('success-container');
    const loadingContainer = document.getElementById('loading-container');
    const shareModal = document.getElementById('share-modal');
    
    // Check if user is already logged in
    document.addEventListener('DOMContentLoaded', () => {
      if (AuthService.isLoggedIn()) {
        loadDashboard();
      }
      
      // Setup tab switching
      setupTabs();
      
      // Setup form submissions
      setupLoginForm();
      setupRegisterForm();
    });
    
    // Setup tab functionality
    function setupTabs() {
      const tabs = document.querySelectorAll('.tab');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Hide error message when switching tabs
          hideError();
          hideSuccess();
          
          // Remove active class from all tabs and contents
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked tab
          tab.classList.add('active');
          
          // Show corresponding tab content
          const tabName = tab.getAttribute('data-tab');
          document.getElementById(`${tabName}-tab`).classList.add('active');
        });
      });
    }
    
    // Setup login form submission
    function setupLoginForm() {
      const loginBtn = document.getElementById('login-btn');
      
      loginBtn.addEventListener('click', async () => {
        // Get form values
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        
        // Validate form
        if (!email || !password) {
          showError('Please enter both email and password');
          return;
        }
        
        try {
          showLoading();
          
          // Call login API
          const response = await AuthService.login({ email, password });
          
          // Retrieve private key with password
          const privateKey = await retrievePrivateKey(password);
          if (!privateKey) {
            showError('Could not retrieve encryption keys. Please register first.');
            hideLoading();
            return;
          }
          
          // Store key temporarily in session
          sessionStorage.setItem('privateKey', privateKey);
          
          hideLoading();
          showSuccess('Login successful!');
          
          // Load dashboard after short delay
          setTimeout(() => {
            loadDashboard();
          }, 500);
        } catch (error) {
          hideLoading();
          showError(error.message || 'Login failed');
        }
      });
      
      // Forgot password handler
      const forgotPasswordBtn = document.getElementById('forgot-password-btn');
      forgotPasswordBtn.addEventListener('click', () => {
        alert('This feature is not yet implemented.');
      });
    }
    
    // Setup registration form submission
    function setupRegisterForm() {
      const registerBtn = document.getElementById('register-btn');
      
      registerBtn.addEventListener('click', async () => {
        // Get form values
        const email = document.getElementById('register-email').value;
        const firstName = document.getElementById('first-name').value;
        const lastName = document.getElementById('last-name').value;
        const password = document.getElementById('register-password').value;
        const confirmPassword = document.getElementById('confirm-password').value;
        
        // Validate form
        if (!email || !password || !confirmPassword) {
          showError('Please fill out all required fields');
          return;
        }
        
        if (password !== confirmPassword) {
          showError('Passwords do not match');
          return;
        }
        
        try {
          showLoading();
          
          // Generate key pair
          const keyPair = await generateKeyPair();
          
          // Store private key (encrypted with password)
          await storePrivateKey(keyPair.privateKey, password);
          
          // Call register API
          const response = await AuthService.register({
            email,
            firstName,
            lastName,
            password,
            publicKey: keyPair.publicKey
          });
          
          hideLoading();
          showSuccess('Registration successful! Please check your email for verification.');
          
          // Switch to login tab
          document.querySelector('[data-tab="login"]').click();
        } catch (error) {
          hideLoading();
          showError(error.message || 'Registration failed');
        }
      });
    }
    
    // Load dashboard view
    async function loadDashboard() {
      authView.style.display = 'none';
      dashboardView.style.display = 'block';
      
      try {
        // Get current user profile
        const userProfile = await UserService.getProfile();
        
        // Get company users
        const companyUsers = await UserService.getCompanyUsers();
        
        // Get secrets
        const secrets = await SecretService.getSecrets();
        
        // Populate dashboard view
        renderDashboard(userProfile, companyUsers, secrets);
        
        // Start polling for new secrets
        startSecretPolling(userProfile.id);
      } catch (error) {
        console.error('Error loading dashboard:', error);
        // If unauthorized, log out and show login
        if (error.message.includes('unauthorized')) {
          AuthService.logout();
          authView.style.display = 'block';
          dashboardView.style.display = 'none';
          showError('Session expired. Please login again.');
        }
      }
    }
    
    // Poll for new secrets periodically
    let pollingInterval;
    let lastSecretCount = 0;
    
    function startSecretPolling(userId) {
      // Clear any existing interval
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
      
      // Store initial secret count
      SecretService.getSecrets().then(secrets => {
        lastSecretCount = secrets.length;
      });
      
      // Check for new secrets every 15 seconds
      pollingInterval = setInterval(async () => {
        try {
          const secrets = await SecretService.getSecrets();
          
          // If there are more secrets than before, show notification
          if (secrets.length > lastSecretCount) {
            // Find new unread secrets meant for current user
            const newUnreadSecrets = secrets.filter(secret => 
              !secret.isRead && secret.receiverId === userId
            );
            
            if (newUnreadSecrets.length > 0) {
              showNotification(`You have ${newUnreadSecrets.length} new secret${newUnreadSecrets.length > 1 ? 's' : ''}!`);
            }
            
            lastSecretCount = secrets.length;
          }
        } catch (error) {
          console.error('Error polling for secrets:', error);
          // If unauthorized, stop polling
          if (error.message.includes('unauthorized')) {
            clearInterval(pollingInterval);
          }
        }
      }, 15000); // 15 seconds
    }
    
    // Show notification
    function showNotification(message) {
      const notificationToast = document.getElementById('notification-toast');
      const notificationMessage = document.getElementById('notification-message');
      
      notificationMessage.textContent = message;
      notificationToast.classList.add('show');
      
      // Auto hide after 5 seconds
      setTimeout(() => {
        notificationToast.classList.remove('show');
      }, 5000);
      
      // Close button
      document.getElementById('notification-close').onclick = () => {
        notificationToast.classList.remove('show');
      };
      
      // Click on notification to refresh dashboard
      notificationToast.onclick = async () => {
        notificationToast.classList.remove('show');
        
        try {
          // Get updated data
          const userProfile = await UserService.getProfile();
          const companyUsers = await UserService.getCompanyUsers();
          const secrets = await SecretService.getSecrets();
          
          // Update dashboard
          renderDashboard(userProfile, companyUsers, secrets);
        } catch (error) {
          console.error('Error refreshing dashboard:', error);
        }
      };
    }
    
    // Render dashboard with user data
    function renderDashboard(userProfile, companyUsers, secrets) {
      // Check if the private key is still available
      console.log('Before render - Private key in session:', !!sessionStorage.getItem('privateKey'));
      
      // Save existing private key for restoration after DOM update
      const existingPrivateKey = sessionStorage.getItem('privateKey');
      
      // Template for dashboard
      const template = `
        <div class="dashboard-header">
          <h2>Welcome, ${userProfile.firstName || 'User'}</h2>
          <div class="dashboard-actions">
            <button class="btn btn-secondary" id="refresh-btn">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 2v6h-6"></path>
                <path d="M3 12a9 9 0 0 1 15-6.7l3-3"></path>
                <path d="M3 22v-6h6"></path>
                <path d="M21 12a9 9 0 0 1-15 6.7l-3 3"></path>
              </svg>
              Refresh
            </button>
            <button class="btn btn-primary" id="logout-btn">Logout</button>
          </div>
        </div>
        
        <div class="section-title">Company Members</div>
        <ul class="user-list">
          ${companyUsers.map(user => `
            <li class="user-item" data-user-id="${user.id}" data-public-key="${encodeURIComponent(user.publicKey)}">
              <div class="user-avatar">${getInitials(user.firstName, user.lastName)}</div>
              <div class="user-info">
                <div class="user-name">${user.firstName || ''} ${user.lastName || ''}</div>
                <div class="user-email">${user.email}</div>
              </div>
            </li>
          `).join('')}
        </ul>
        
        <div class="section-title">Your Secrets</div>
        <ul class="secret-list">
          ${secrets.length ? secrets.map(secret => `
            <li class="secret-item ${!secret.isRead && secret.receiverId === userProfile.id ? 'unread' : ''}" data-secret-id="${secret.id}">
              <div class="secret-sender">
                ${secret.senderId === userProfile.id 
                  ? `To: ${secret.receiver.firstName || ''} ${secret.receiver.lastName || ''}`
                  : `From: ${secret.sender.firstName || ''} ${secret.sender.lastName || ''}`}
              </div>
              <div class="secret-date">${new Date(secret.createdAt).toLocaleString()}</div>
            </li>
          `).join('') : '<p>No secrets shared yet</p>'}
        </ul>
      `;
      
      // Set dashboard content
      dashboardView.innerHTML = template;
      
      // Restore the private key if it was lost during DOM manipulation
      if (existingPrivateKey && !sessionStorage.getItem('privateKey')) {
        console.log('Restoring private key after DOM update');
        sessionStorage.setItem('privateKey', existingPrivateKey);
      }
      
      // Add event listeners
      setupDashboardEvents(userProfile);
      
      // Check if the private key is still available after rendering
      console.log('After render - Private key in session:', !!sessionStorage.getItem('privateKey'));
    }
    
    // Setup dashboard event listeners
    function setupDashboardEvents(userProfile) {
      // Logout button
      const logoutBtn = document.getElementById('logout-btn');
      logoutBtn.addEventListener('click', () => {
        AuthService.logout();
        sessionStorage.removeItem('privateKey');
        authView.style.display = 'block';
        dashboardView.style.display = 'none';
        
        // Clear the polling interval when logging out
        if (pollingInterval) {
          clearInterval(pollingInterval);
        }
      });
      
      // Refresh button
      const refreshBtn = document.getElementById('refresh-btn');
      refreshBtn.addEventListener('click', async () => {
        try {
          // Show some loading indicator
          refreshBtn.disabled = true;
          refreshBtn.innerHTML = `
            <svg class="spin" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
            </svg>
            Refreshing...
          `;
          
          // Fetch updated data
          const userProfile = await UserService.getProfile();
          const companyUsers = await UserService.getCompanyUsers();
          const secrets = await SecretService.getSecrets();
          
          // Update dashboard
          renderDashboard(userProfile, companyUsers, secrets);
        } catch (error) {
          console.error('Error refreshing dashboard:', error);
          alert('Failed to refresh data');
        }
      });
      
      // User item click (to share secret)
      const userItems = document.querySelectorAll('.user-item');
      userItems.forEach(item => {
        item.addEventListener('click', () => {
          const userId = item.getAttribute('data-user-id');
          const publicKey = item.getAttribute('data-public-key');
          openShareModal(userId, publicKey);
        });
      });
      
      // Secret item click (to view secret)
      const secretItems = document.querySelectorAll('.secret-item');
      secretItems.forEach(item => {
        item.addEventListener('click', async () => {
          const secretId = item.getAttribute('data-secret-id');
          try {
            const secret = await SecretService.getSecretById(secretId);
            
            // If user is recipient and secret is unread, mark as read
            if (secret.receiverId === userProfile.id && !secret.isRead) {
              await SecretService.markAsRead(secretId);
              item.classList.remove('unread');
            }
            
            // If user is recipient, decrypt and show the secret
            if (secret.receiverId === userProfile.id) {
              const privateKey = sessionStorage.getItem('privateKey');
              console.log('Private key available?', !!privateKey);
              if (!privateKey) {
                alert('Unable to decrypt: Private key not available');
                // Attempt to recover by prompting for password and retrieving key
                const password = prompt('Please enter your password to access your encryption key:');
                if (password) {
                  try {
                    const recoveredKey = await retrievePrivateKey(password);
                    if (recoveredKey) {
                      // Store key temporarily in session
                      sessionStorage.setItem('privateKey', recoveredKey);
                      // Try to decrypt again
                      const decryptedData = await decryptWithPrivateKey(secret.encryptedData, recoveredKey);
                      alert(`Decrypted Secret: ${decryptedData}`);
                    } else {
                      alert('Could not recover your encryption key. Try logging out and back in.');
                    }
                  } catch (recoveryError) {
                    console.error('Error recovering private key:', recoveryError);
                    alert('Failed to recover encryption key. Try logging out and back in.');
                  }
                }
                return;
              }
              
              try {
                const decryptedData = await decryptWithPrivateKey(secret.encryptedData, privateKey);
                alert(`Decrypted Secret: ${decryptedData}`);
              } catch (error) {
                alert('Failed to decrypt the secret');
                console.error('Decryption error:', error);
              }
            } else {
              // If user is sender, just show that it was sent
              alert(`Secret sent to ${secret.receiver.firstName || ''} ${secret.receiver.lastName || ''}`);
            }
          } catch (error) {
            console.error('Error viewing secret:', error);
            alert('Failed to load secret');
          }
        });
      });
    }
    
    // Open share modal to send a secret
    function openShareModal(receiverId, publicKey) {
      // Set modal data attributes
      shareModal.setAttribute('data-receiver-id', receiverId);
      shareModal.setAttribute('data-public-key', publicKey);
      
      // Show modal
      shareModal.style.display = 'flex';
      
      // Setup modal buttons
      const cancelBtn = document.getElementById('cancel-share-btn');
      const confirmBtn = document.getElementById('confirm-share-btn');
      
      // Cancel button
      cancelBtn.onclick = () => {
        shareModal.style.display = 'none';
        document.getElementById('secret-text').value = '';
      };
      
      // Confirm button
      confirmBtn.onclick = async () => {
        const secretText = document.getElementById('secret-text').value;
        if (!secretText) {
          alert('Please enter a secret to share');
          return;
        }
        
        try {
          // Get the public key from the attribute (and decode it)
          const publicKey = decodeURIComponent(shareModal.getAttribute('data-public-key'));
          
          // Encrypt the secret with recipient's public key
          const encryptedData = await encryptWithPublicKey(secretText, publicKey);
          
          // Send to API
          await SecretService.shareSecret({
            receiverId: parseInt(receiverId),
            encryptedData
          });
          
          alert('Secret shared successfully!');
          shareModal.style.display = 'none';
          document.getElementById('secret-text').value = '';
          
          // Reload dashboard to show new secret
          loadDashboard();
        } catch (error) {
          console.error('Error sharing secret:', error);
          alert('Failed to share secret');
        }
      };
    }
    
    // Helper functions for UI
    function showError(message) {
      errorContainer.textContent = message;
      errorContainer.style.display = 'block';
      successContainer.style.display = 'none';
    }
    
    function hideError() {
      errorContainer.style.display = 'none';
    }
    
    function showSuccess(message) {
      successContainer.textContent = message;
      successContainer.style.display = 'block';
      errorContainer.style.display = 'none';
    }
    
    function hideSuccess() {
      successContainer.style.display = 'none';
    }
    
    function showLoading() {
      loadingContainer.style.display = 'block';
    }
    
    function hideLoading() {
      loadingContainer.style.display = 'none';
    }
    
    function getInitials(firstName, lastName) {
      const firstInitial = firstName ? firstName.charAt(0).toUpperCase() : '?';
      const lastInitial = lastName ? lastName.charAt(0).toUpperCase() : '';
      return lastInitial ? `${firstInitial}${lastInitial}` : firstInitial;
    }
  </script>
</body>
</html> 